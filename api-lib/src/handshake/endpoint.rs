use std::fs::{create_dir_all, File};
use std::io::Write;
use crate::handshake::endpoint::Dir::{ValidDir, VariableDir};

pub fn write_endpoint(method: &str, raw_path: &str, struct_name: &str) {
    let method_upper = method.to_uppercase();
    let method_lower = method.to_lowercase();
    // TODO: Vite ENV
    let host = "import.meta.env.VITE_API_URL?? ''";

    create_dir_all(format!("../src/api{raw_path}/")).unwrap();
    let mut file = File::create(format!("../src/api{raw_path}/{method_lower}.ts")).unwrap();

    let comment= r#"
// This file was generated by [papi]. Do not edit this file manually.
	import user from '$lib/http/user';
	import { get as getStore } from 'svelte/store';
	
"#;
    let response_import = "import { type Response, request_inner } from '$lib/http/response';\n";


    let imp = format!("import type {{ {struct_name} as ");
    let from = " } from";

    let vars = format!("const method = '{method_lower}'; \nconst host = {host}; \n");

    let import = format!("{imp}{method_upper}{from} '$lib/endpoint_defines/{raw_path}/{method_upper}'; \n");
    let fn_decl = function_decl(method_lower, method_upper, raw_path);

    file.write_all(format!("{comment}{response_import}{vars}{import}{fn_decl}").as_bytes()).unwrap();
}

enum Dir {
    ValidDir(String),
    VariableDir(String)
}

fn function_decl(mut fn_name: String, method: String, raw_path: &str) -> String {
    // TODO: EXTRACT DYNAMIC VARIABLES FROM PATH
    let mut vars = vec![];
    let mut new_dirs = vec![];
    let dirs = raw_path.split('/');

    for dir in dirs {
        if dir.starts_with('{') && dir.ends_with('}') {
            let var = &dir[1..dir.len() - 1];
            vars.push(format!("{var}"));
            new_dirs.push(VariableDir(var.to_string()))
        } else {
            new_dirs.push(ValidDir(dir.to_string()))
        }
    }
    
    if fn_name == "delete" {
        fn_name = "del".to_string();
    }

    let fn_init = format!("export default async function {fn_name}(in_val: {method}['in_type'],");
    let fn_init_1 = vars.iter().fold(String::new(), |acc, y| format!("{acc} {y}: string,"));
    let fn_init_2 = format!("query?: {method}['query_type']): Promise<Response<{method}['out_data_type']>>");

    let mut path = new_dirs.iter().fold(String::new(), |acc, y| match y {
        ValidDir(d) => format!("{acc}/{d}"),
        VariableDir(v) => format!("{acc}/' + {v} + '")
    });
    
    path.remove(0);

    let fn_decl= r#" {
  const params = new URLSearchParams();
  for (const key in query) {
    params.set(key, query[key]);
  }
	const request_init: RequestInit = {
    credentials: 'include',
		method: method,
		headers: {
        'Authorization-User': getStore(user)?.username,
		},
	}
"#;

    let req_init = if method == "POST" || method == "PUT" || method == "PATCH" {
        r#"
  request_init.body = JSON.stringify(in_val);
  request_init.headers = {
    'Content-Type': 'application/json',
  }
    "#
    } else {
        ""
    };

    let end = r#"
	return request_inner(host, path, params, request_init);
}
  "#;

    format!("{fn_init}{fn_init_1}{fn_init_2}{fn_decl}  const path = '{path}'\n{req_init}{end}")
}

use std::fs::{create_dir_all, File};
use std::io::Write;
use serde::{Deserialize, Serialize};
use ts_rs::TS;
use crate::routes::auth::{Authenticated, login::LoginForm};

#[derive(Clone, Debug, Serialize, Deserialize, TS)]
// TODO: PATH DEFINED BY USER
#[ts(export, export_to = "../src/lib/endpoint_defines/auth/login/POST.ts")]
struct __Endpoint {
  // TODO: TYPES DEFINED BY USER
  in_type: LoginForm,
  out_data_type: Authenticated
}

#[cfg(test)]
#[test]
fn __export_write_endpoint() {
  // TODO: DEFINED BY USER
  let method = "POST";
  let raw_path = "auth/login";
  
  create_dir_all(format!("../src/api/{raw_path}/")).unwrap();
  let mut file = File::create(format!("../src/api/{raw_path}/endpoint.ts")).unwrap();
  
  let method_upper = method.to_uppercase();
  let method_lower = method.to_lowercase();
  // TODO: Vite ENV
  let host = "http://localhost:8080/";

  let comment= r#"
// This file was generated by [papi]. Do not edit this file manually.

"#;
  let response_import = "import type { Response } from '$lib/handshake/';\n";
  
  
  let imp = "import type { __Endpoint as ";
  let from = " } from";

  // TODO: EXTRACT DYNAMIC VARIABLES FROM PATH
  let path = raw_path;

  let vars = format!("const method = '{method_lower}'; \nconst path = '{path}'; \nconst host = '{host}'; \n");

  // TODO: LOOP OVER ENDPOINTS
  let import = format!("{imp}{method_upper}{from} './{method_upper}'; \n");
  let fn_decl = function_decl(method_lower, method_upper);

  file.write_all(format!("{comment}{response_import}{vars}{import}{fn_decl}").as_bytes()).unwrap();
}

fn function_decl(fn_name: String, method: String) -> String {
  let fn_init = format!("export async function {fn_name}(in_val: {method}['in_type']): Promise<Response<{method}['out_data_type']>");
  
  let fn_decl= r#"
  
 {
  const searchParams = new URLSearchParams();
	const request_init: RequestInit = {
		method: method,
		headers: {},
	}
"#;

  let req_init = if method == "POST" {
    r#"
  request_init.body = JSON.stringify(in_val);
  request_init.headers = {
    'Content-Type': 'application/json',
  }
    "#
  } else if method == "GET" || method == "DELETE" {
    r#"
  for (const key in in_val) {
    // @ts-ignore
    searchParams.set(key, data[key]);
  }
    "#
  } else {
    ""
  };

  let end = r#"
	const response = await fetch(host + path + "?" + searchParams.toString(), request_init);
	if (!response.ok) {
		try {
			const error = await response.json();
			if (error.message) {
				return { type: "err", error: error.message };
			}
		} catch {
			return {
				type: "err",
				error: {
					message: response.statusText,
					kind: {
            err_kind: "single",
            response: {
              kind: "private_fatal",
              message: "Unknown error!",
              origin: "fetch"
            }
          }
				},
			}
		}
	}
	
	const json = await response.json();
	return { type: "ok", data: json}
}
  "#;

  format!("{fn_init}{fn_decl}{req_init}{end}")
}
